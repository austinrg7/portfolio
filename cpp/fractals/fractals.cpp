/*
Name: Austin Gillis

Program Name: Dragon Curve Fractal Experimenter

Purpose: Use the fractal representation technique to generate a dragon curve fractal. This technique generates 
highly detailed vector representations of certain real life objects. Trees,plants,flowers are good choices as
they have a natural fractal structure ("The Algorithmic Beauty of Plants"). The dragon curve is a less practical, 
but visually stunning image that can be generated by the fractal technique. The fractal starts with a single segment 
and grows by copying the existing segments and rotating that copy 90 degrees about the z-axis. One iteration is a line,
two is a right angle, three is two right angles connected at 90 degrees, and by 10 iterations a complex dragon curve 
pattern appears. In order to make the representation more interesting, at iteration 8 and 16 instead of copying and
rotating about the z-axis the whole fractal is rotated 90 degrees about an arbitrary axis (0.28968, 0.761858, -0.57936),
which utilizes quaternion rotation.

Input (from keyboard): +           = increase the speed of the animation
                       -           = decrease the speed of the animation
                       r           = resets any rotations or 'camera' changes preformed by the user and resets 
                                     the animation to the default speed
                       q           = quit
                       esc         = quit
                       arrow keys  = move the 'camera' vertically and horizontally
      
      (from mouse)   : Right click = Brings up the options menu, containing
                                     1) Fractal Options         a)Restart default b)Pick start 
                                     2) Change Segment Length   a)Increase        b)Decrease  
                                     3) Change Segment Radius   a)Increase        b)Decrease    
                                     4) Quit                        
                       Left click  = (GUI) preforms the corresponding action
                                     (VP1) selects fractal start location

Output: An openGL window with animation of the dragon curve fractal as it grows through 16 iterations
        and changes by mouse and keyboard input
*/

using namespace std;

#include <stdio.h>
#include <stdlib.h>
#include <GL/glut.h>
#include <iostream>
#include <vector>
#include <math.h>
#include <time.h>

//Begin globals---
static GLsizei width,height; // OpenGL window size.
static float Xangle = 0.0,Yangle = 0.0,Zangle = 0.0; //Controls allow the user to rotate the fractal about each axis. These track how much the user has rotated the fractal

float xCam = 0.0;//Initial look at position x
float yCam = 0.0;//Initial look at position y
float zCam = 20.75;//Initial look at position z 

float growthRotY = 0;//As fractal grow some adjustments necessary. This one such adjustment tracks rotation about the y axis
float growthRotZ = 0;// As above but for rotation about the z axis
float growthAdjustH = 0;//Another adjustment for growth. This one tracks movement of the look at position up or down
float growthAdjustW = 0;//As above but tracks left or right
float growthAdjustZ = 0;//Another adjustment for growth. This one tracks zooming in or out

int numClicks = 0;//Used to track fractal growth
int progress;//Used to record current growth of fractal if user decides to change a segment property
bool first = true;//Certain things only need to happen on first loop through. Setting it to false afterwards ensures that
bool userStartPos=false;//Prevents user from adding point after fractal growth has begun.
bool animating=true;//Used to prevent idling in the draw function if not animating
float startZ=-3;//Whether user selected start or default start fractal begins growth at z=-3 

long NUM_TICKS = 750000; //idle time between animation frames

//--- End globals

//Begin function declarations---
void mymenu(int); // menu callback function
void adjustPerspect(); 
void resetCameraK();
void resetCameraM();
void writeBitmapString(void *font, char mystring[] );
//---End function declarations

//---Start object declarations 
class Fractal {

public:
    Fractal(){
        seg_size = 0.4;
        radius = 0.08;
        subdivs = 32;
        theta = -1.57079633;
        cosHalfTheta = cos(theta / 2);
        sinHalfTheta = sin(theta / 2);
        quaternions= new float[4];
        computeQuats();
        makeTransformMatrix();
    }; // constructor

    //Begin public member functions---
    void makeGUI();
    
    void addPoint(float x,float y,float z);
    
    void copyRotate2d();
    void rotate3d();
    
    void draw();
    void recreate();

    void deleteDrawing();
    //---End public member functions

    //openGL window consists of 2 viewports one for the fractal and one for the GUI
    float maxX;//Max viewport 1 x coordinate 
    float maxY;//Max window y coordinate 
    float winMax;//Max window x coordinate

    float radius;//Radius of the cylinders that make up each segment of the fractal 
    float seg_size;//Height of the cylinders that make up each segment of the fractal
    //---End public properties

private:
    //Begin private member functions---
    float* normalizeVec(float* toNorm);
    void makeTransformMatrix();
    vector<float> multiplyVecs(float xCoord,float yCoord,float zCoord);
    void computeQuats();

    void drawCylinder(float x1,float y1,float z1,float x2,float y2,float z2,GLUquadricObj* quadric);
    void drawCylinderHelper(float x1,float y1,float z1,float x2,float y2,float z2);

    void makeLabels (char mystring[], int x, int y);
    void makeLabelsBig (char mystring[], int x, int y);
    //---End private member functions
    
    //Begin private properties---
    float theta;//Angle of rotation
    float cosHalfTheta;//value for cos(half the angle of rotation). Used for computing quaternion values
    float sinHalfTheta;//value for sin(half the angle of rotation). Used for computing quaternion values

    float* quaternions;//pointer to an array which will hold the quaternion units

    vector<vector<float> > transformMatrix;//Matrix to hold the quaternion rotation transformation matrix 

    int subdivs;//Number of disks to use to draw the cylinder
    //Variables below are used to create a color gradient from (1,0,0) to (0,1,0) to (0,0,1) to (1,0,1)
    int startA;int endA;float incA;
    int startB;int endB;float incB;
    int endC;float incC;

    vector<float> xCoords;//Holds x coordinate for each vertex of the dragon curve
    vector<float> yCoords;//Holds y coordinate for each vertex of the dragon curve
    vector<float> zCoords;//Holds z coordinate for each vertex of the dragon curve
    //---End private properties
};

Fractal dragonCurve;
//---End object declarations

//Begin object member function definitions---
void Fractal::addPoint(float x,float y,float z){
    /*  
    Adds a point to list of vertex coordinates 

    Input: Float x,y,z representing a coordinate in 3d space
    Return: None, but 
    xCoords, yCoords, zCoords vectors size increases by one by adding input point to end of vector
    */
    xCoords.push_back(x);
    yCoords.push_back(y);
    zCoords.push_back(z);
}

void Fractal::computeQuats(){
    /*  
    Computes the quaternion values

    Input: None
    Return: None, but 
    quaternions array is updated to contain the necessary values
    */
    float* normalized;
    float unNormAxis[] = {10,26.3,-20};
    normalized=normalizeVec(unNormAxis);
    quaternions[0] = normalized[0] * sinHalfTheta;
    quaternions[1] = normalized[1] * sinHalfTheta;
    quaternions[2] = normalized[2] * sinHalfTheta;
    quaternions[3] = cosHalfTheta;
    
}

float* Fractal::normalizeVec(float* toNorm){
    /*  
    Computes the quaternion values

    Input: floating pointer to array with rotation axis to be normalized
    Return: a pointer to the normalized array
    */
    float* normalized= new float[3];
    float norm = toNorm[0] * toNorm[0] + toNorm[1] * toNorm[1] + toNorm[2] * toNorm[2];
    float scl = 1 / (sqrt(norm));

    normalized[0]=(toNorm[0] * scl);
    normalized[1]=(toNorm[1] * scl);
    normalized[2]=(toNorm[2] * scl);

    return normalized;
}

void Fractal::makeTransformMatrix(){
    /*  
    Makes the transformation matrix necessary to rotate p(x,y,z,1) about an arbitrary axis
    Adapted from algorithm on pg 9 of pdf linked below: 
    http://www.cs.cmu.edu/afs/cs/academic/class/15462-s12/www/lec_slides/3DRotationNotes.pdf

    Input: None
    Return: None,but
    transformationMatrix now represents the transformation matrix necessary to rotate p(x,y,z,1) about an arbitrary axis 
    */

    /*      General form for quaternion tfm matrix for rotation about an arbitrary axis  
            
                                1-2Y²-2Z²    2XY-2WZ    2XZ+2WY    0
                                2XY+2WZ    1-2X²-2Z²    2YZ-2WX    0
                                2XZ-2WY    2YZ+2WX    1-2X²-2Y²    0
                                0             0          0         1 

    */

    //First step to creating above matrix 
    float xs,ys,zs;
    xs = 2*quaternions[0];  ys = quaternions[1];  zs = 2*quaternions[2];
    
    //Second step to creating above matrix.  All variables necessary to make row calculated  
    float wx,wy,wz,xx,xy,xz,yy,yz,zz;
    wx = quaternions[3]*xs;  wy = quaternions[3]*ys;  wz = quaternions[3]*zs;
    xx = quaternions[0]*xs;  xy = quaternions[0]*ys;  xz = quaternions[0]*zs;
    yy = quaternions[1]*ys;  yz = quaternions[1]*zs;  zz = quaternions[2]*zs;

    //Compute the values for each row of the tfm
    float row0[] = {1-(yy+zz),xy-wz,xz+wy,0};
    float row1[] = {xy+wz,1-(xx+zz),yz-wx,0};
    float row2[] = {xz-wy,yz+wx,1-(xx+yy),0};
    float row3[] = {0,0,0,1};

    //Copy into a vector
    vector<float> vrow0 (row0,row0+4);
    vector<float> vrow1 (row1,row1+4);
    vector<float> vrow2 (row2,row2+4);
    vector<float> vrow3 (row3,row3+4);

    //Add to vector of vectors (matrix)
    transformMatrix.push_back(vrow0);
    transformMatrix.push_back(vrow1);
    transformMatrix.push_back(vrow2);
    transformMatrix.push_back(vrow3);
}

vector<float> Fractal::multiplyVecs(float xCoord,float yCoord,float zCoord){
    /*  
    Computes vector C= M[4][4] x N[4][1] 

    Input: X, Y, Z values for row values in matrix N (in desc)
    Return: A vector containing the result of the matrix multiplication
    */

    vector<float> results;//Vector to hold results
    vector<float> points;//Vector to hold N[4][1]

    //Add points to the matrix
    points.push_back(xCoord);
    points.push_back(yCoord);
    points.push_back(zCoord);
    points.push_back(1.0);


    float temp;//holds values that need to be summed as part of matrix multiplication algorithm
    for (int i = 0; i < 4; i++) {
        temp = 0;
        for (int j = 0; j < 4; j++) {
            //Multiply the transformation matrix and the point matrix
            temp += transformMatrix[i][j] * points[j];
        }
        //record result of the multiplication for each row
        results.push_back(temp);
    }

    return results;
}

void Fractal::copyRotate2d(){
    /*  
    Makes a copy of the fractal in its current state and rotates that copy about the last vertex 

    Input: none
    Return: none, but
    (x&&y&&z)Coords updates to include the rotated copy 
    */

    float newX,newY;
    float newZ = zCoords.back();

    float dX = xCoords.back();
    float dY = yCoords.back();

    int origSize = xCoords.size() - 1;
    for (int i = origSize; i >= 0; i--) {
        newX = (xCoords[i] * cos(theta)) - (yCoords[i] * sin(theta)) + ((-1 * dX * cos(theta)) + (dY * sin(theta)) + dX);
        xCoords.push_back(newX);
        newY = (xCoords[i] * sin(theta)) + (yCoords[i] * cos(theta)) + ((-1 * dX * sin(theta)) - (dY * cos(theta)) + dY);
        yCoords.push_back(newY);
        zCoords.push_back(newZ);
    }
}

void Fractal::rotate3d(){
    /*  
    Rotates the fractal in its current state theta radians about the arbitrary axis

    Input: none
    Return: none, but
    (x&&y&&z)Coords updated to rotated location
    */
    int origSize = xCoords.size() - 1;
    for (int i = origSize; i >= 0; i--) {
        vector<float> temp;
        temp = multiplyVecs(xCoords[i],yCoords[i],zCoords[i]);

        xCoords[i] = temp[0];
        yCoords[i] = temp[1];
        zCoords[i] = temp[2];
    }
}

void Fractal::drawCylinder(float x1,float y1,float z1,float x2,float y2,float z2,GLUquadricObj* quadric){
    /*  
    Draws a cylinder between two points p0(x,y,z) and p1(x,y,z) 

    Input: p0(x,y,z), p1(x,y,z), and a quadric object used to render the cylinder
    Return: none, but
    a cylinder is drawn between p0(x,y,z) and p1(x,y,z)

    Adapted from code found at http://lifeofaprogrammergeek.blogspot.com/2008/08/opengl-example-rendering-cylinders.html 
    Put into the public domain by the author Curran Kelleher. 
    */

    float vx = x2 - x1;
    float vy = y2 - y1;
    float vz = z2 - z1;

    //handle the degenerate case of z1 == z2 with an approximation
    if (vz == 0)
        vz = .00000001;

    float v = sqrt(vx * vx + vy * vy + vz * vz);
    float ax = 57.2957795 * acos(vz / v);
    if (vz < 0.0)
        ax = -ax;
    float rx = -vy * vz;
    float ry = vx * vz;
    glPushMatrix();

    //draw the cylinder body
    glTranslatef(x1,y1,z1);
    glRotatef(ax,rx,ry,0.0);
    gluQuadricOrientation(quadric,GLU_OUTSIDE);
    gluCylinder(quadric,radius,radius,v,subdivs,1);

    //draw the first cap
    gluQuadricOrientation(quadric,GLU_INSIDE);
    gluDisk(quadric,0.0,radius,subdivs,1);
    glTranslatef(0,0,v);

    //draw the second cap
    gluQuadricOrientation(quadric,GLU_OUTSIDE);
    gluDisk(quadric,0.0,radius,subdivs,1);
    glPopMatrix();
}

void Fractal::drawCylinderHelper(float x1,float y1,float z1,float x2,float y2,float z2){
    /*  
    Helper function for the drawCylinder function. Establishes some basic glutQuadric properties  

    Input: none
    Return: none, but
    calls the drawCylinder function which draws a cylinder between two points

    Adapted from code found at http://lifeofaprogrammergeek.blogspot.com/2008/08/opengl-example-rendering-cylinders.html 
    Put into the public domain by the author Curran Kelleher. 
    */

    //the same quadric can be re-used for drawing many cylinders
    GLUquadricObj* quadric = gluNewQuadric();
    gluQuadricNormals(quadric,GLU_SMOOTH);
    drawCylinder(x1,y1,z1,x2,y2,z2,quadric);
    gluDeleteQuadric(quadric);
}

void Fractal::draw(){
    /*  
    Draws the fractal in its current state

    Input: none
    Return: none, but
    fractal is draw on the screen
    */

    clock_t endWait;//used for animation. holds value for the time the animation can progress to the next frame

    //Get viewport ready
    glClearColor(0.0,0.0,0.0,0.5);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    adjustPerspect();

    //Break vertices into sections so they can be colored differently
    int sectionA = xCoords.size() / 3;
    int sectionB = sectionA + (0.7 * (0.666 * xCoords.size()));

    //Used to create color gradients
    startA = 1;endA = 0;incA = 0;
    startB = 1;endB = 0;incB = 0;
    endC = 0;incC = 0;
    
    
    //Color each section using a different color gradient
    for (int i = 0; i < xCoords.size() - 1; i++) {

        if (i < sectionA) {
            glColor3f(startA - incA,endA + incA,0);
            incA += .0003;
        }
        else if (i < sectionB) {
            incB += .000125;
            glColor3f(0,startB - incB,endB + incB);
        }

        else {
            incC += .0008;
            glColor3f(endC + incC,0,1);
        }
        //draw the segments
        drawCylinderHelper(xCoords[i],yCoords[i],zCoords[i],xCoords[i + 1],yCoords[i + 1],zCoords[i + 1]);
    }
    //If this draw was called during animation wait until its time to advance to the next frame
    if(animating){
        endWait = clock() + NUM_TICKS;
        //Wait until the tick ends
        while (clock() < endWait);
    }
    //Make GUI
    makeGUI();
    //Flush to opengl window
    glutSwapBuffers();
}

void Fractal::recreate(){
    /*  
    Recreates the fractal up to its current iteration using a new segment size or radius

    Input: none
    Return: none, but
    (x&&y&&z)Coords recreated up to current iteration using a new segment size or radius
    */
    
    //copy down the old start point
    float startX=xCoords[0]; 
    float startY=yCoords[0];
    float startZ=yCoords[0];

    //Erase the old data
    deleteDrawing();
    //Re-add original point
    addPoint(startX,startY,startZ);
    //Calculate the new x2,y2,z2
    float x2,y2,z2;
    x2= startX -seg_size;
    y2= startY;
    z2=startZ;
    //Re-add the new second vertex
    addPoint(x2,y2,z2);

    int rotCheck;//Used to check if a roate3d is required instead of copyRotate2d
    int iterations=0;//Used to keep track of how much has been reconstructed
    //Above completes 2 iterations of the fractal growth
    iterations+=2;

    //Allow the fractal to grow back to its previous size sing the new params
    while (iterations < progress){
        rotCheck = iterations;
        //Rotate3d on iterations 8 and 16
        if (rotCheck % 8 == 0){
            //Make a few adjustments to keep in frame as fractal grows
            if (iterations == 8) {
                growthRotZ -= 40;
                growthRotY += 44.5;
                                
            }
            //Make a few adjustments to keep in frame as fractal grows
            else{
                growthAdjustH += 7.0;
                growthRotZ -= 50;
                growthAdjustW -= 3.0;
            }

            rotate3d();
        }
        //Else copyRotate2d 
        else{
            //Make a few adjustments to keep in frame as fractal grows
            if (iterations == 10) 
                growthRotZ += 40;
            //Make a few adjustments to keep in frame as fractal grows
            else if (iterations == 15) {
                growthRotZ -= 40;
                growthAdjustH -= 10.0;
                growthAdjustZ += 5.0;
            } 
            copyRotate2d();
        }
        //Iteration completed
        iterations++;
    }    

}

void Fractal::makeLabels (char mystring[], int x, int y) {
    /*  
    Makes the labels for the GUI buttons

    Input: A string representing the label and the x,y position to place the text
    Return: none, but
    label added to GUI
    */
    glRasterPos3f(x,y, 0.0);
    writeBitmapString( GLUT_BITMAP_HELVETICA_18, mystring);
}

void Fractal::makeLabelsBig (char mystring[], int x, int y) {
    /*  
    Makes slightly larger labels for the GUI buttons

    Input: A string representing the label and the x,y position to place the text
    Return: none, but
    larger label (for +/- buttons) added to GUI
    */
    glRasterPos3f(x,y, 0.0);
    writeBitmapString( GLUT_BITMAP_TIMES_ROMAN_24, mystring);
}

void Fractal::makeGUI(){
    /*  
    Creates the GUI

    Input: none
    Return: none, but
    the GUI is created containing 8 buttons controlling different view options
    */

    //Calculate the width of GUI viewport
    float leftViewWidth,winWidth,winHeigth;
    if(first){
        leftViewWidth=800;
        winWidth=1000;
        winHeigth=700;
    }

    else{
        leftViewWidth=maxX;
        winWidth=winMax;
        winHeigth=maxY;
    }
    //----
    
    //GUI only needs 2d projection
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0,200,-800,0);
    glViewport(leftViewWidth+10,0,winWidth,winHeigth);
    
    //Switch back to draw mode
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glPointSize(50.0); //Make point really large to look like a square button

    //add 8 squares for buttons for rotate x,y,z (rot x pos, rot x neg   rot y pos, rot y neg  rot z pos, rot z neg  zoom in, zoom out)
    glBegin(GL_POINTS);

        glColor3f (0.0, 1.0, 0.0); //Increase buttons are green
        //Can just use device coordinates in the viewport
        glVertex2f(5,-100);
        glVertex2f(5,-300);
        glVertex2f(5,-450);
        glVertex2f(5,-600);
    
       
        glColor3f (1.0, 0.0, 0.0);//Decrease buttons are red
        glVertex2f(26,-100);
        glVertex2f(26,-300);
        glVertex2f(26,-450);
        glVertex2f(26,-600);

     
    glEnd();

    glColor3f(1.0, 1.0, 1.0);//White text for labels
    //Various label components
    char s1[] = "Rotate about";
    char s2[] = "X-axis";
    char s3[] = "Y-axis";
    char s4[] = "Z-axis";
    char s5[] = "Zoom";
    char s6[] = "-";
    char s7[] = "+";
    //------

    //Make button instruction labels
    makeLabels(s1,5,-350);makeLabels(s2,10,-370);
    makeLabels(s1,5,-500);makeLabels(s3,10,-520);
    makeLabels(s1,5,-650);makeLabels(s4,10,-670);
    makeLabels(s5,12,-155);

    glColor3f(0.0, 0.0, 0.0);// +/- part of button is white for visibility
    //Add +/- to appropriate buttons
    makeLabelsBig(s6,25,-110);makeLabelsBig(s6,25,-310); makeLabelsBig(s6,25,-460); makeLabelsBig(s6,25,-610);
    makeLabelsBig(s7,4,-110);makeLabelsBig(s7,4,-310); makeLabelsBig(s7,4,-460); makeLabelsBig(s7,4,-610);

}

void Fractal::deleteDrawing(){
    /*  
    Deletes the fractal by removing all the vertices from the data structure

    Input: none
    Return: none, but
    (x&&y&&z)Coords are emptied
    */
    xCoords.clear();
    yCoords.clear();
    zCoords.clear();
}
//---End object member function definitions

//Begin miscellaneous function definitions---
void writeBitmapString(void *font, char mystring[] ){  
    /*  
    Writes the bitmap string with the label text

    Input: desired font, string to make into bitmap string
    Return: none, but
    bitmap string is created to be rasterized in label function
    */
   int i;
   for (i = 0; mystring[i] != '\0'; i++) glutBitmapCharacter(font, mystring[i]);
}
//---End miscellaneous function definitions

//Begin openGl helper function definitions---
void init(){
    /*  
    Clears the openGl with a black background

    Input: none
    Return: none, but
    openGL window is cleared with a black background
    */
    glClearColor(0.0,0.0,0.0,0.5);
}


void adjustPerspect(){
    /*  
    Adjusts the perspective of the fractal viewport

    Input: none
    Return: none, but
    as perspective values are changed the camera adjust accordingly
    */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1,1,-1,1,1.5,500.0);
    gluLookAt(xCam,yCam,zCam + growthAdjustZ,0.0,0.0,0.0,0.0,1.0,0.0);
    glViewport(0, 0, dragonCurve.maxX,dragonCurve.maxY);
    //glScissor(0, 0, dragonCurve.maxX,dragonCurve.maxY);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glTranslatef(xCam + growthAdjustW,yCam + growthAdjustH,0);

    glRotatef(Zangle + growthRotZ,0.0,0.0,1.0);
    glRotatef(Yangle + growthRotY,0.0,1.0,0.0);
    glRotatef(Xangle,1.0,0.0,0.0);
}

void resetCameraK(){
    /*  
    Undoes any camera changes the user made 

    Input: none
    Return: none, but
    camera returned to default position
    */

    glRotatef(-Zangle,0.0,0.0,1.0);
    glRotatef(-Yangle,0.0,1.0,0.0);
    glRotatef(-Xangle,1.0,0.0,0.0);

    xCam = 0.0;
    yCam = 0.0;
    zCam = 20.75;
    Xangle = Yangle = Zangle = 0;
}

void resetCameraM(){
    /*  
    Undoes any camera changes made since the start of the program

    Input: none
    Return: none, but
    camera returned to default position so fractal can grow from start
    */
    xCam = 0.0;
    yCam = 0.0;
    zCam = 20.75;
    Xangle = Yangle = Zangle = growthRotY = growthRotZ = growthAdjustH = growthAdjustZ = growthAdjustW = 0;
}
//---End openGL helper function definitions

//Begin openGL function definitions---
void display(){
    /*  
    On first pass clears out the window background and makes GUI
    Subsequent passes update the openGL window by swapping buffers

    Input: none
    Return: none, but
    the scene changes
    */
    if (first) {
        glClear(GL_COLOR_BUFFER_BIT);

        dragonCurve.makeGUI();

    }

    glutSwapBuffers();
}

static void Idle(void){
    /*  
    Handles animation of dragon curve's growth

    Input: none
    Return: none, but
    the curve's growth is animated in the fractal viewport
    */

    int rotCheck;//Used to check if calling copyRotate2d or rotate3d

    first = false;
    numClicks++;

    //Idle function called whenever not receiving input so numClicks get very large and messes up further calculations
    //Set it to 17 if it goes over 17 as necessary for rest of program
    if (numClicks>17)
        numClicks=17;

    //Add the default first cylinder
    if (numClicks == 1 && !userStartPos) {
        dragonCurve.addPoint(-10.0,1.5,startZ); 
        dragonCurve.addPoint(-10.0-dragonCurve.seg_size,1.5,startZ);
        dragonCurve.draw();        
    }

    //Add rest algorithmically
    else if (numClicks < 17) {

        rotCheck = numClicks;

        //Rotate3d on numClicks=8,16
        if (rotCheck % 8 == 0) {
            //Growth adjustments to keep fractal in frame
            if (numClicks == 8) {
                growthRotZ -= 40;
                growthRotY += 44.5;
                dragonCurve.rotate3d();
            }
            //Growth adjustments to keep fractal in frame
            else {
                growthAdjustH += 7.0;
                growthRotZ -= 50;
                growthAdjustW -= 3.0;
                dragonCurve.rotate3d();
            }
            //Draw up to current iteration
            dragonCurve.draw();
        }
        //copyRoate2d on numClicks!=8,16
        else {
            //Growth adjustments to keep fractal in frame
            if (numClicks == 10) 
                growthRotZ += 40;
            //Growth adjustments to keep fractal in frame 
            else if (numClicks == 15) {
                growthRotZ -= 40;
                growthAdjustH -= 10.0;
                growthAdjustZ += 5.0;
            }
            dragonCurve.copyRotate2d();
            //Draw up to current iteration
            dragonCurve.draw();
        }
    } 
}

void resize(int w,int h){
    /*  
    Handles window resizing

    Input: window width and height
    Return: none, but
    values necessary for creating 2 viewports are updated and projection set up
    */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1,1,-1,1,1.5,500.0);
    glMatrixMode(GL_MODELVIEW);

    width = w;
    height = h;

    dragonCurve.winMax = width;
    dragonCurve.maxX = dragonCurve.winMax*.8;
    dragonCurve.maxY = height;
}

void keyboard(unsigned char key,int x,int y){
    /*  
    Handles keyboard input

    Input: character user hit on keyboard
    Return: none, but
    the window updates based on certain key presses
    */
    switch (key) {
    //reset all user changes when r is pressed
    case 'r':
        NUM_TICKS=750000; 
        resetCameraK();
        dragonCurve.draw();
        break;
    //Speed up animation when + (ASCII 43) pressed
    case 43: NUM_TICKS-= (NUM_TICKS/5);
            glutPostRedisplay();
        break;
    //Slow down animation when - (ASCII 45) pressed
    case 45:NUM_TICKS+= (NUM_TICKS/5);
            glutPostRedisplay();
        break;
    //Quit when <esc> (ASCII 27) or q are pressed
    case 27:
    case 'q':
             cout << "\nGoodbye" << endl;
             exit(1);
    }
}

void handleArrows(int key, int x, int y){
    /*  
    Handles special keyboard input

    Input: arrow key user hit on keyboard
    Return: none, but
    the camera pans up/down and left/right based on the arrow keys pressed
    */
    switch (key) {
    //Pan up
    case GLUT_KEY_UP:
        yCam -= 0.5;
        break;
    //Pan down
    case GLUT_KEY_DOWN:
        yCam += 0.5;
        break;
    //Pan left
    case GLUT_KEY_LEFT:
        xCam += 0.5;
        break;
    //Pan right
    case GLUT_KEY_RIGHT:
        xCam -= 0.5;
        break;
    }
    dragonCurve.draw();
    glutPostRedisplay();
} 

void myMouse (int button, int state, int x, int y){
    /*  
    Handles mouse input

    Input: left/right click and its position in display coordinates
    Return: none, but
    if in the GUI viewport left clicking operated the buttons
    if pick start location chosen left click choses the start point
    */

        /*        Display                       World

            0,0  _____  width,0         -15,15  _____  15,15    
                |     |                        |     |
                |     |                        |     |
                |     |                        |     |
        0,height ¯¯¯¯¯  width,height   -15,-15  ¯¯¯¯¯  15,-15
        
        */
   
    //World coordinate corresponding to device coordinate
    float sceneX,sceneY;
    //Clicking in viewport 1 after selecting the option to pick start location
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN && userStartPos && x<dragonCurve.maxX) {
        //Convert from display coordinates to world coordinates            
        //reduce range of to [0,1], increase to [0,30], and shift to [-15,-15]
        sceneX= (30*(x/dragonCurve.maxX))-15;
        sceneY= (30*(y/dragonCurve.maxY))-15;

        //Have to reflect because bottom of the screen from mouse is positive
        dragonCurve.addPoint(sceneX,-sceneY,startZ);
        dragonCurve.addPoint(sceneX - dragonCurve.seg_size,-sceneY,startZ);
        numClicks++;
        //start up animation again        
        glutIdleFunc(Idle);
    }
    //Clicking in viewport 2
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN && x>dragonCurve.maxX) {
        
        //Define the positions of the buttons so necessary function can be carried out when it's clicked
        if (x>=810 && x<=860 && y>=60 && y<=110){
            zCam -= 7;
        }
        else if (x>=915 && x<=965 && y>=60 && y<=110){
            zCam += 7;
        }
        else if (x>=810 && x<=860 && y>=235 && y<=285){
            Yangle -= 5.0;
            if (Yangle > 360.0)
                Yangle -= 360.0;
        }
        else if (x>=915 && x<=965 && y>=235 && y<=285){
            Yangle += 5.0;
            if (Yangle < 0.0)
                Yangle += 360.0;
        }
        else if (x>=810 && x<=860&& y>=370 && y<=420){
            Xangle -= 5.0;
            if (Xangle > 360.0)
                Xangle -= 360.0;
        }
        else if (x>=915 && x<=965&& y>=370 && y<=420){
            Xangle += 5.0;
            if (Xangle < 0.0)
                Xangle += 360.0;
        }
        else if (x>=810 && x<=860 && y>=500 && y<=550){
            Zangle += 5.0;
            if (Zangle > 360.0)
                Zangle -= 360.0;
        }
        else if (x>=915 && x<=965 && y>=500 && y<=550){
            Zangle -= 5.0;
            if (Zangle < 0.0)
                Zangle += 360.0;
        }

        //Display the changes
        dragonCurve.draw();
        glutPostRedisplay();
    }
    
}

void initmenu(){
    /*  
    Initializes right click menu

    Input: none
    Return: none, but
    the value of the option the user picks is sent to mymenu
    */
    //Hold value for fractal choice, radius change, and length change
    int optionsF, changeR, changeL;

    //Fractal options submenu
    optionsF = glutCreateMenu(mymenu);
    glutAddMenuEntry("Restart fractal with default values",1);
    glutAddMenuEntry("Pick fractal start location",2);
    //Segment length submenu
    changeL = glutCreateMenu(mymenu);
    glutAddMenuEntry("Increase length",3);
    glutAddMenuEntry("Decrease length",4);
    //Segment radius submenu
    changeR = glutCreateMenu(mymenu);       
    glutAddMenuEntry("Increase radius",5);
    glutAddMenuEntry("Decrease radius",6);
 
    //Main menu
    glutCreateMenu(mymenu);
    glutAddSubMenu("Fractal Options",optionsF);
    glutAddSubMenu("Change Segment Length",changeL);
    glutAddSubMenu("Change Segment Radius",changeR);
    glutAddMenuEntry("Quit",7);

    //Attach to a right click
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

void mymenu(int value){
    /*  
    Initializes right click menu

    Input: Integer representing the choice the user made in the options menu
    Return: none, but
    the value action corresponding to the users choice in the menu is carried out
    */
    switch (value) {
    //Restart with default params
    case 1:
        resetCameraM();
        dragonCurve.deleteDrawing();
        NUM_TICKS =750000;
        numClicks = 0;
        userStartPos = false;
        animating = true;
        dragonCurve.seg_size = 0.4;
        dragonCurve.radius = 0.08;
        break;
    //Restart with user defined start location
    case 2:
        userStartPos = true;
        resetCameraM();
        dragonCurve.deleteDrawing();
        numClicks = 0;
        glutIdleFunc(NULL);
        break;
    //Increase segment size
    case 3:
        glutIdleFunc(NULL);
        animating = false;
        dragonCurve.seg_size += 0.25 * dragonCurve.seg_size;
        resetCameraM();
        progress = numClicks;
        dragonCurve.recreate();
        dragonCurve.draw();
        animating = true;
        glutIdleFunc(Idle);
        break;
    //Decrease segment size
    case 4:
        glutIdleFunc(NULL);
        animating = false;
        dragonCurve.seg_size -= 0.25 * dragonCurve.seg_size;
        resetCameraM();
        progress = numClicks;
        dragonCurve.recreate();
        dragonCurve.draw();
        animating = true;
        glutIdleFunc(Idle);
        break;
    //Increase segment radius
    case 5:
        glutIdleFunc(NULL);
        animating = false;
        dragonCurve.radius += 0.333 * dragonCurve.radius;
        resetCameraM();
        progress = numClicks;
        dragonCurve.recreate();
        dragonCurve.draw();
        animating = true;
        glutIdleFunc(Idle);
        break;
    //Decrease segment radius
    case 6:
        glutIdleFunc(NULL);
        animating = false;
        dragonCurve.radius -= 0.333 * dragonCurve.radius;
        resetCameraM();
        progress = numClicks;
        dragonCurve.recreate();
        dragonCurve.draw();
        animating = true;
        glutIdleFunc(Idle);
        break;
    //Quit
    case 7:
        cout << "Goodbye" << endl;
        exit(1);
    }
}
//---End openGL function definitions

int main(int argc,char** argv){
    //Output controls to console
    cout<<"\nUsage instructions"<<endl;
    cout<<"------------------"<<endl;
    cout<<"- Basic usage requires no input"<<endl;
    cout<<"- From keyboard: The arrow keys move the 'camera' vertically and horizontally, \n'+'/'-' increase/decrease the speed of the animation, 'r' resets any rotations\nor 'camera' changes preformed by the user and resets the animation to the deault speed, q or esc quits the program and closes the openGL window."<<endl;
    cout<<"- A left click on the buttons in the GUI preforms the action corresponding to \nthat button"<<endl;
    cout<<"- A right click in the openGL window brings up the options menu, containg\n1) Fractal Options 2) Change Segment Length 3) Change Segment Radius 4) Quit"<<endl;
    cout<<endl;
    cout<<"1. Allows the user to a) restart the animation with default paramaters or \nb) restart the animation with a chosen start point: left click desired location after slecting"<<endl;
    cout<<endl;
    cout<<"2. Allows the user to a) increase the length of the segements of the fractal \nb) decrease the length of the segements of the fractal"<<endl;
    cout<<endl;
    cout<<"3. Allows the user to a) increase the radius of the segements of the fractal \nb) decrease the radius of the segements of the fractal"<<endl;
    cout<<endl;
    cout<<"4. Quits the program and closes the openGL window."<<endl;

    //Begin openGL initializations---
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(1000,700);
    glutInitWindowPosition(200,0);
    glutCreateWindow("Dragon Curve Fractal");
    init();
    initmenu();
    //---End openGL initializations
    
    glutDisplayFunc(display);
    glutReshapeFunc(resize);
    
    //Begin openGL event handlers---
    glutMouseFunc (myMouse);
    glutKeyboardFunc(keyboard);
    glutSpecialFunc(handleArrows);
    //---End openGL event handlers

    //Animation function
    glutIdleFunc(Idle);

    glutMainLoop();

    return 0;
}